CREATE SEQUENCE MYTEST
MINVALUE 100
MAXVALUE 10000
START WITH 5000
INCREMENT BY -5
CACHE 20;
--HOW MANU NUMBERS TO HAVE ACCESS TO
SELECT MYTEST.NEXTVAL FROM DUAL;

INSERT INTO school VALUES (MYTEST.NEXTVAL, 'Harvard');

CREATE OR REPLACE VIEW MYVIEW
AS
SELECT title AS A_LIST_OF_STUFF FROM album UNION SELECT name FROM artist;

SELECT * FROM MYVIEW WHERE a_list_of_stuff LIKE 'T%' OR a_list_of_stuff LIKE 'B%';

CREATE INDEX MYINDEX ON album (artistid);
--generally we dont mess with creating indecies

CREATE OR REPLACE TRIGGER MYTRIGGER
BEFORE INSERT ON STUDENT
FOR EACH ROW
BEGIN
SELECT MYTEST.NEXTVAL INTO:NEW.S_ID FROM DUAL;
END;
/

INSERT INTO STUDENT VALUES(67, 'Deonta', 5);
--OR
INSERT INTO STUDENT (S_NAME, SCH_ID) VALUES ('DEONTA', 5);

ALTER TABLE STUDENT ADD CONSTRAINT PKID PRIMARY KEY(S_ID);

INSERT INTO STUDENT (S_NAME, SCH_ID) VALUES ('Danny McBride', 4);

/*USER DEFINED FUNCTIONS*/
--NUMBER (HOW MANY DIGITS, HOW MANY DECIMAL PLACES)
CREATE OR REPLACE FUNCTION CALC_TAX (T_ID IN NUMBER, TAX IN NUMBER, TESTDOG IN NUMBER:=2)
RETURN NUMBER AS TOTAL_PRICE NUMBER(10,2);
BEGIN
SELECT UNITPRICE INTO TOTAL_PRICE FROM TRACK WHERE TRACKID = T_ID;
RETURN (TOTAL_PRICE + (TOTAL_PRICE * TAX))*TESTDOG;
END;
/

SELECT CALC_TAX(568, .08, 3) FROM DUAL;

CREATE OR REPLACE FUNCTION AREA (SIDEONE IN NUMBER, SIDETWO IN NUMBER, USERCHOICE IN VARCHAR2)
RETURN NUMBER AS FINAL_AREA NUMBER(10,2);
BEGIN
CASE USERCHOICE
    WHEN 'Circle' THEN FINAL_AREA:= (SIDEONE * SIDEONE) * 3.14159264;
    WHEN 'Square' THEN FINAL_AREA:= (SIDEONE * SIDETWO);
    WHEN 'Triangle' THEN FINAL_AREA:= (0.5 * SIDEONE * SIDETWO);
END CASE;
RETURN FINAL_AREA;
END;
/

SELECT AREA(2, 5, 'Circle') FROM DUAL;
SELECT AREA(4, 5, 'Square') FROM DUAL;
SELECT AREA(3, 3, 'Triangle') FROM DUAL;
--SELECT CIRCLE_AREA(4, 5, 2) FROM DUAL;

CREATE OR REPLACE FUNCTION SQUARE_UP(MY_INPUT IN NUMBER)
RETURN NUMBER AS ROUNDED_NUMBER NUMBER(10,2);
BEGIN
RETURN MY_INPUT * MY_INPUT;
END;
/

SELECT SQUARE_UP(4) FROM DUAL;

CREATE OR REPLACE FUNCTION AREATWO (SIDELEN IN NUMBER, NUMSIDES IN NUMBER)
RETURN NUMBER AS FINAL_AREA NUMBER(10,2);
apo NUMBER(10, 2);
BEGIN
    apo := (SIDELEN)/(2 * TAN(180/NUMSIDES));
    RETURN (apo * (SIDELEN * NUMSIDES))/2;
END;
/

SELECT AREATWO(8, 6) FROM DUAL; 

/*stored procedures*/
CREATE OR REPLACE PROCEDURE MYPRO(NAME IN VARCHAR2) AS 
BEGIN
INSERT INTO SCHOOL VALUES (MYTEST.NEXTVAL, NAME);
COMMIT;
END;
/

EXEC MYPRO('MIT');

/*MORE COMPLICATED VERSION*/

CREATE TABLE BEAR(
BEAR_ID NUMBER PRIMARY KEY,
BEAR_TYPE_ID NUMBER,
BEAR_NAME VARCHAR2(100),
BEAR_BIRTHDATE DATE,
BEAR_WEIGHT NUMBER DEFAULT 200,
CAVE_ID NUMBER
);

CREATE TABLE BEAR_TYPE(
BEAR_TYPE_ID NUMBER PRIMARY KEY,
BEAR_TYPE_NAME VARCHAR2(100)
);

CREATE TABLE CAVE(
CAVE_ID NUMBER PRIMARY KEY,
CAVE_NAME VARCHAR2(100),
MAX_BEARS NUMBER DEFAULT 4
);

CREATE TABLE BEEHIVE(
BEEHIVE_ID NUMBER PRIMARY KEY,
BEEHIVE_WEIGHT NUMBER DEFAULT 50
);

CREATE TABLE BEAR_BEEHIVE(
BEAR_ID NUMBER,
BEEHIVE_ID NUMBER,
PRIMARY KEY (BEAR_ID, BEEHIVE_ID)
);

ALTER TABLE BEAR 
ADD CONSTRAINT FK_BEAR_BEAR_TYPE 
FOREIGN KEY(BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID);

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_CAVE
FOREIGN KEY(CAVE_ID) REFERENCES CAVE(CAVE_ID);

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEEHIVE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID);

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEAR
FOREIGN KEY (BEAR_ID) REFERENCES BEAR(BEAR_ID);

ALTER TABLE BEAR
ADD CONSTRAINT CK_BEAR_WEIGHT_POSITIVE
CHECK(BEAR_WEIGHT > 0);

ALTER TABLE BEEHIVE
ADD CONSTRAINT CK_BEEHIVE_WEIGHT_POSITIVE
CHECK(BEEHIVE_WEIGHT > 0);

ALTER TABLE CAVE
ADD CONSTRAINT UQ_CAVE_NAME
UNIQUE(CAVE_NAME);

ALTER TABLE BEAR_TYPE
ADD CONSTRAINT UQ_BEAR_TYPE_NAME
UNIQUE(BEAR_TYPE_NAME);


ALTER TABLE BEAR_TYPE DROP CONSTRAINT UQ_BEAR_TYPE_NAME;
ALTER TABLE BEAR DROP CONSTRAINT FK_BEAR_BEAR_TYPE;
ALTER TABLE BEAR DROP CONSTRAINT FK_BEAR_CAVE;
ALTER TABLE BEAR_BEEHIVE DROP CONSTRAINT FK_BEAR_BEEHIVE_BEEHIVE;
ALTER TABLE BEAR_BEEHIVE DROP CONSTRAINT FK_BEAR_BEEHIVE_BEAR;
ALTER TABLE BEAR DROP CONSTRAINT CK_BEAR_WEIGHT_POSITIVE;
ALTER TABLE BEEHIVE DROP CONSTRAINT CK_BEEHIVE_WEIGHT_POSITIVE;
ALTER TABLE CAVE DROP CONSTRAINT UQ_CAVE_NAME;
ALTER TABLE BEAR_TYPE DROP CONSTRAINT UQ_BEAR_TYPE_NAME;

DROP TABLE BEAR;
DROP TABLE BEAR_TYPE;
DROP TABLE BEAR_BEEHIVE;
DROP TABLE BEEHIVE;
DROP TABLE CAVE;

CREATE OR REPLACE PROCEDURE BEARPRO(CAVE_NAME IN VARCHAR2, 
BEAR_NAME IN VARCHAR2, BEAR_BIRTHDATE IN DATE) AS
COUNTER NUMBER:= MYTEST.NEXTVAL;
BEGIN
INSERT INTO CAVE VALUES(COUNTER, CAVE_NAME, 4);
INSERT INTO BEEHIVE VALUES(COUNTER, 50);
INSERT INTO BEAR_TYPE VALUES(1, 'Black');
INSERT INTO BEAR VALUES(COUNTER, 1, BEAR_NAME, BEAR_BIRTHDATE, 2000, COUNTER);
COMMIT;
END;
/

EXEC BEARPRO('MATTSCAVE', 'MATTSBEAR', DATE '2013-06-03');


/*cursors
procedure with a cursor as an out parameter*/


CREATE OR REPLACE PROCEDURE GET_ALL_ALBUMS(S OUT SYS_REFCURSOR) IS
BEGIN
OPEN S FOR
SELECT ALBUMID, TITLE FROM ALBUM;
END;
/

SET SERVEROUT ON;

DECLARE S SYS_REFCURSOR;
ALBUM_ID ALBUM.ALBUMID%TYPE;--SET ALBUM_ID TO WHATEVER THE ACTUAL ALBUMID IS
ALBUMNAME ALBUM.TITLE%TYPE;
BEGIN
    GET_ALL_ALBUMS(S);
    LOOP
    FETCH S INTO ALBUM_ID, ALBUMNAME;
    EXIT WHEN S%NOTFOUND; --BREAK OUT OF LOOP ONCE NO MORE ROWS ARE AVAILABLE
    DBMS_OUTPUT.PUT_LINE(ALBUM_ID || ' IS CURRENT ALBUM ID, '||ALBUMNAME||' IS CURRENT ALBUM NAME');
    END LOOP;
    CLOSE S;
END;
/