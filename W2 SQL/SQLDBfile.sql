--07/25/2919


CREATE SEQUENCE MYTESTSEQ 
MINVALUE 100
MAXVALUE 10000
START WITH 5000
INCREMENT BY -5
CACHE 20;

SELECT MYTESTSEQ.NEXTVAL FROM DUAL;

INSERT INTO SCHOOL VALUES(MYTESTSEQ.NEXTVAL, 'Harvard');

CREATE OR REPLACE VIEW MYVIEW 
AS 
SELECT TITLE AS A_LIST_OF_STUFF 
FROM ALBUM
UNION 
SELECT NAME FROM ARTIST;

SELECT * FROM MYVIEW
WHERE A_LIST_OF_STUFF LIKE 'T%' OR A_LIST_OF_STUFF LIKE 'B%';

CREATE INDEX MYINDEX 
ON ALBUM(ARTISTID);

--DUAL is a dummy table that we use to fill out our result set. 
SELECT * FROM ALBUM;
--trigger
CREATE OR REPLACE TRIGGER MYTRIG
BEFORE INSERT ON STUDENT
FOR EACH ROW
BEGIN
SELECT MYTESTSEQ.NEXTVAL INTO: NEW.S_ID FROM DUAL;
END;
/  --this is to mark the end of the trigger

INSERT INTO STUDENT (S_NAME,SCH_ID) VALUES ('KENNY G',1);
INSERT INTO STUDENT (S_NAME,SCH_ID) VALUES ('KENNY G',1);

CREATE OR REPLACE FUNCTION CALC_TAX
(T_ID IN NUMBER, TAX IN NUMBER)
RETURN NUMBER AS TOTAL_PRICE NUMBER (10,2);
BEGIN
SELECT UNITPRICE INTO TOTAL_PRICE FROM TRACK
WHERE TRACKID =T_ID;
RETURN TOTAL_PRICE +(TOTAL_PRICE*TAX);
END;
/

select calc_tax(568, .08) from dual;

ALTER TABLE STUDENT
ADD CONSTRAINT PKID
PRIMARY KEY(S_ID);
(t_id in number, tax in number)
return number as total_price number (10,2);
begin
select unitprice into total_price from track
where trackid =t_id;
return total_price +(total_price*tax);
end;
/


--USE CAL_TAX
SELECT CAL_TAX(564,.08) FROM DUAL;
SELECT CAL_TAX(548,0.8) FROM DUAL;

--Area of circle
CREATE OR REPLACE FUNCTION CIRCLE_AREA (RADIUS IN NUMBER)
RETURN NUMBER AS FINAL_RADIUS NUMBER(10,2);
BEGIN
--SELECT INVOICEID INTO FINAL_RADIUS FROM INVOICE;
RETURN (RADIUS * RADIUS) * 3.14159264;
END;
/

SELECT CIRCLE_AREA(809879564743435654324567654324567847409) FROM DUAL;


--square
CREATE OR REPLACE FUNCTION SQUARE_UP(MY_INPUT IN NUMBER)
RETURN NUMBER AS ROUNDED_NUMBER NUMBER(10,2);
BEGIN
RETURN (MY_INPUT * MY_INPUT);
END;
/

SELECT SQUARE_UP(4) FROM DUAL;

-----------------stored procedure
CREATE OR REPLACE PROCEDURE MYSTOPRO
(NAME IN VARCHAR2)
AS
BEGIN
INSERT INTO SCHOOL VALUES(MYTESTSEQ.NEXTVAL,NAME);
COMMIT;
END;
/

EXECUTE MYSTOPRO('MIT');

CREATE TABLE BEAR(
BEAR_ID NUMBER PRIMARY KEY, 
BEAR_TYPE_ID NUMBER,
BEAR_NAME VARCHAR2(100),
BEAR_BIRTHDATE DATE,
BEAR_WEIGHT NUMBER DEFAULT 200,
CAVE_ID NUMBER);

CREATE TABLE BEAR_TYPE(
BEAR_TYPE_ID NUMBER PRIMARY KEY,
BEAR_TYPE_NAME VARCHAR2(100));

CREATE TABLE CAVE(
CAVE_ID NUMBER PRIMARY KEY,
CAVE_NAME VARCHAR2(100),
MAX_BEARS_NUMBER  NUMBER DEFAULT 4);

CREATE TABLE BEEHIVE(
BEEHIVE_ID NUMBER PRIMARY KEY,
BEEHIVE_WEIGHT NUMBER DEFAULT 50);

CREATE TABLE BEAR_BEEHIVE(
BEAR_ID NUMBER,
BEEHIVE_ID NUMBER,
PRIMARY KEY(BEAR_ID,BEEHIVE_ID));

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_BEAR_TYPE
FOREIGN KEY(BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID);

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_CAVE
FOREIGN KEY(CAVE_ID) REFERENCES CAVE (CAVE_ID);

ALTER TABLE BEAR_BEEHIVE 
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEEHIVE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID)

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEEHIVE_BEAR
FOREIGN KEY(BEAR_ID) REFERENCES BEAR(BEAR_ID);

ALTER TABLE BEAR 
ADD CONSTRAINT CK_BEAR_WEIGHT_POSITIVE
CHECK(BEAR_WEIGHT>0);

ALTER TABLE BEEHIVE
ADD CONSTRAINT CK_BEEHIVE_WEIGHT_POSITIVE
CHECK(BEEHIVE_WEIGHT>0);

ALTER TABLE CAVE
ADD CONSTRAINT UQ_CAVE_NAME
UNIQUE(CAVE_NAME);

ALTER TABLE BEAR_TYPE
ADD CONSTRAINT UQ_TYPE_NAME
UNIQUE (BEAR_TYPE_NAME);

CREATE OR REPLACE PROCEDURE BEARPRO
(CAVE_NAME IN VARCHAR2, BEAR_NAME IN VARCHAR2, BEAR_BIRTHDATE IN DATE)
AS
BEGIN
INSERT INTO CAVE VALUES(1, CAVE_NAME, 4);
INSERT INTO BEEHIVE VALUES(MYTESTSEQ.NEXTVAL, 50);
INSERT INTO BEAR_TYPE VALUES(1,'BLACK');
INSERT INTO BEAR VALUES(MYTESTSEQ.NEXTVAL, 1, BEAR_NAME, BEAR_BIRTHDATE, 2000, 1);
COMMIT;
END;
/
EXECUTE BEARPRO('MATTSCAVE','MATTBONDS',DATE'2013-06-26');

--cursors
--procedure with a cursor as an out parameter

CREATE OR REPLACE PROCEDURE GET_ALL_ALBUMS
(S OUT SYS_REFCURSOR)
IS 
BEGIN
OPEN S FOR 
SELECT ALBUMID, TITLE FROM ALBUM;
END;
/

SET SERVEROUT ON;

DECLARE S SYS_REFCURSOR;
ALBUM_ID ALBUM.ALBUMID%TYPE; --set album_id to whatever datatype the actual album_id is
ALBUMNAME ALBUM.TITLE%TYPE;
BEGIN 
    GET_ALL_ALBUMS(S);
    LOOP
    FETCH S INTO ALBUM_ID, ALBUMNAME;
    EXIT WHEN S%NOTFOUND; --break out of loop when no more rows available
    DBMS_OUTPUT.PUT_LINE(ALBUM_ID||' IS CURRENT ID, '||ALBUMNAME||' IS CURRENT NAME');
    END LOOP;
    CLOSE S;
    END;
    /
    
